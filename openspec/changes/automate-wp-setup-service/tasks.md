# Tasks: Automate WordPress Setup Service

## Phase 1: WordPress Authentication Layer
- [x] Research WordPress Application Password API endpoints and nonce requirements
- [x] Implement Python class `WordPressAuthenticator` with methods:
  - `authenticate_with_password(url, username, password)` - Returns session/token
  - `verify_admin_access()` - Validates user has admin capabilities
  - `get_nonce(action)` - Retrieves security nonces for privileged operations
- [x] Add cookie jar management for maintaining WordPress sessions
- [x] Add error handling for invalid credentials, network failures
- [ ] Write unit tests for authentication flow with mock WordPress responses

## Phase 2: Plugin Installation API
- [x] Implement `WordPressPluginInstaller` class with methods:
  - `upload_plugin_zip(session, plugin_zip_path)` - Uploads plugin via `/wp-admin/plugin-install.php`
  - `activate_plugin(session, plugin_slug)` - Activates plugin via `/wp-admin/plugins.php`
  - `check_plugin_status(session, plugin_slug)` - Returns active/inactive/not-installed
- [x] Handle WordPress nonce validation for plugin upload
- [x] Handle multipart/form-data encoding for ZIP file upload
- [x] Add retry logic for transient network failures
- [ ] Write integration tests against local WordPress Docker container

## Phase 3: API Key Retrieval
- [x] Implement `WordPressOptionsFetcher` class:
  - `get_option(session, option_name)` - Retrieves option via REST API or direct query
  - `get_migrator_api_key(session)` - Specifically retrieves Custom WP Migrator API key
- [x] Add fallback method using WordPress REST API `/wp-json/wp/v2/settings` (requires auth)
- [x] Add validation to ensure retrieved API key format is correct (32-char alphanumeric)
- [ ] Write tests for option retrieval

## Phase 4: Setup Service HTTP API
- [x] Create FastAPI/Flask service with endpoints:
  - `POST /setup` - Accepts `{url, username, password}`, returns `{api_key, status}`
  - `GET /health` - Health check endpoint
- [x] Implement request validation (URL format, non-empty credentials)
- [x] Implement response formatting (JSON with success/error messages)
- [x] Add logging for all operations (auth attempts, plugin install, key retrieval)
- [x] Add timeout configuration (default 300s for full setup)
- [ ] Write API integration tests with pytest

## Phase 5: Clone Script Integration
- [ ] Modify `clone.sh` to accept optional `--auto-setup` flag
- [ ] Add logic to call setup service before cloning:
  - If `--auto-setup` provided, call `/setup` endpoint for source/target
  - Store returned API keys in environment variables
  - Proceed with existing clone flow
- [ ] Add environment variable support for setup service URL (`SETUP_SERVICE_URL`)
- [ ] Update usage documentation in script comments
- [ ] Test end-to-end: credentials → setup → clone → verify

## Phase 6: Deployment & Documentation
- [x] Create `requirements.txt` with dependencies:
  - `fastapi`
  - `uvicorn[standard]`
  - `requests`
  - `beautifulsoup4`
  - `python-multipart`
  - `boto3` (AWS SDK)
  - `paramiko` (SSH)
- [x] Create Dockerfile for ECS deployment:
  - Base image: `python:3.11-slim`
  - Install dependencies
  - Copy plugin ZIP file to `/app/plugin.zip`
  - Expose port 8000
  - CMD: `uvicorn main:app --host 0.0.0.0 --port 8000`
- [x] Create `.dockerignore` excluding tests, cache, venv
- [x] Add docker-compose service definition for local testing
- [x] Document API endpoints in OpenAPI/Swagger format (auto-generated by FastAPI)
- [x] Implement `/provision` endpoint for EC2 provisioning
- [ ] Create example usage guide showing:
  - Running service via Docker
  - Calling `/provision` endpoint
  - Calling `/clone` endpoint
  - Calling `/restore` endpoint
  - Troubleshooting common auth failures
- [ ] Add error code reference (auth failed, plugin install failed, etc.)
- [ ] Add EC2 deployment notes:
  - Auto Scaling Group configuration
  - User data script with Docker + Nginx
  - CloudWatch custom metrics
  - SSH key management

## Phase 7: EC2 Infrastructure Setup (New)
- [ ] Create EC2 AMI with Docker and Nginx pre-installed
- [ ] Create Auto Scaling Group configuration:
  - Min: 1 instance, Max: 5 instances
  - Instance type: t3.medium
  - Launch template with user data
- [ ] Configure Application Load Balancer:
  - HTTPS listener with wildcard SSL
  - Host-based routing rules
  - Health check endpoint
- [ ] Set up CloudWatch custom metrics:
  - container_count per instance
  - Scaling policy based on container count
- [ ] Configure DNS for wildcard subdomain:
  - `*.temp.your-domain.com` → ALB

## Validation Criteria
- [ ] Service can authenticate with vanilla WordPress (no custom plugins)
- [ ] Service successfully uploads and activates Custom WP Migrator plugin
- [ ] Service retrieves valid API key after plugin activation
- [ ] Full workflow: `./clone.sh --auto-setup` completes without manual intervention
- [ ] Error messages are actionable (e.g., "Invalid credentials for https://example.com")
- [ ] Service handles timeouts gracefully (WordPress slow response, network lag)
